// Code generated by protoc-gen-go-flags. DO NOT EDIT.
// versions:
// - protoc-gen-go-flags v0.0.0-dev
// - protoc              v3.17.3
// source: wkts.proto

package test

import (
	flagsplugin "github.com/TheThingsIndustries/protoc-gen-go-flags/flagsplugin"
	golang "github.com/TheThingsIndustries/protoc-gen-go-flags/golang"
	pflag "github.com/spf13/pflag"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	wrapperspb "google.golang.org/protobuf/types/known/wrapperspb"
)

// AddSelectFlagsForMessageWithWKTs adds flags to select fields in MessageWithWKTs.
func AddSelectFlagsForMessageWithWKTs(flags *pflag.FlagSet, prefix string, hidden bool) {
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("double-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("double-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("double-values", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("double-values", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("float-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("float-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("float-values", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("float-values", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("int32-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("int32-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("int32-values", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("int32-values", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("int64-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("int64-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("int64-values", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("int64-values", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("uint32-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("uint32-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("uint32-values", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("uint32-values", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("uint64-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("uint64-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("uint64-values", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("uint64-values", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("bool-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("bool-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("bool-values", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("bool-values", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-values", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-values", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("bytes-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("bytes-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("bytes-values", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("bytes-values", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("empty-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("empty-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("empty-values", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("empty-values", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("timestamp-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("timestamp-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("timestamp-values", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("timestamp-values", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("duration-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("duration-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("duration-values", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("duration-values", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("field-mask-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("field-mask-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("field-mask-values", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("field-mask-values", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value-values", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value-values", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("list-value-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("list-value-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("list-value-values", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("list-value-values", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("struct-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("struct-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("struct-values", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("struct-values", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("any-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("any-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("any-values", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("any-values", prefix), false), flagsplugin.WithHidden(hidden)))
}

// SelectFromFlags outputs the fieldmask paths forMessageWithWKTs message from select flags.
func PathsFromSelectFlagsForMessageWithWKTs(flags *pflag.FlagSet, prefix string) (paths []string, err error) {
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("double_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("double_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("double_values", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("double_values", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("float_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("float_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("float_values", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("float_values", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("int32_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("int32_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("int32_values", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("int32_values", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("int64_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("int64_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("int64_values", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("int64_values", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("uint32_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("uint32_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("uint32_values", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("uint32_values", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("uint64_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("uint64_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("uint64_values", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("uint64_values", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("bool_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("bool_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("bool_values", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("bool_values", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_values", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_values", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("bytes_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("bytes_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("bytes_values", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("bytes_values", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("empty_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("empty_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("empty_values", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("empty_values", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("timestamp_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("timestamp_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("timestamp_values", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("timestamp_values", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("duration_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("duration_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("duration_values", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("duration_values", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("field_mask_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("field_mask_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("field_mask_values", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("field_mask_values", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value_values", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value_values", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("list_value_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("list_value_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("list_value_values", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("list_value_values", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("struct_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("struct_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("struct_values", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("struct_values", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("any_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("any_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("any_values", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("any_values", prefix))
	}
	return paths, nil
}

// AddSetFlagsForMessageWithWKTs adds flags to select fields in MessageWithWKTs.
func AddSetFlagsForMessageWithWKTs(flags *pflag.FlagSet, prefix string, hidden bool) {
	flags.AddFlag(flagsplugin.NewFloat64Flag(flagsplugin.Prefix("double-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewFloat64SliceFlag(flagsplugin.Prefix("double-values", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewFloat32Flag(flagsplugin.Prefix("float-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewFloat32SliceFlag(flagsplugin.Prefix("float-values", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewInt32Flag(flagsplugin.Prefix("int32-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewInt32SliceFlag(flagsplugin.Prefix("int32-values", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewInt64Flag(flagsplugin.Prefix("int64-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewInt64SliceFlag(flagsplugin.Prefix("int64-values", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewUint32Flag(flagsplugin.Prefix("uint32-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewUint32SliceFlag(flagsplugin.Prefix("uint32-values", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewUint64Flag(flagsplugin.Prefix("uint64-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewUint64SliceFlag(flagsplugin.Prefix("uint64-values", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("bool-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolSliceFlag(flagsplugin.Prefix("bool-values", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewStringFlag(flagsplugin.Prefix("string-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewStringSliceFlag(flagsplugin.Prefix("string-values", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBytesFlag(flagsplugin.Prefix("bytes-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBytesSliceFlag(flagsplugin.Prefix("bytes-values", prefix), "", flagsplugin.WithHidden(hidden)))
	// FIXME: Skipping EmptyValue because this WKT is currently not supported.
	// FIXME: Skipping EmptyValues because this repeated WKT is currently not supported.
	flags.AddFlag(flagsplugin.NewTimestampFlag(flagsplugin.Prefix("timestamp-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewTimestampSliceFlag(flagsplugin.Prefix("timestamp-values", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewDurationFlag(flagsplugin.Prefix("duration-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewDurationSliceFlag(flagsplugin.Prefix("duration-values", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewStringSliceFlag(flagsplugin.Prefix("field-mask-value", prefix), "", flagsplugin.WithHidden(hidden)))
	// FIXME: Skipping FieldMaskValues because this repeated WKT is currently not supported.
	// FIXME: Skipping ValueValue because this WKT is currently not supported.
	// FIXME: Skipping ValueValues because this repeated WKT is currently not supported.
	// FIXME: Skipping ListValueValue because this WKT is currently not supported.
	// FIXME: Skipping ListValueValues because this repeated WKT is currently not supported.
	// FIXME: Skipping StructValue because this WKT is currently not supported.
	// FIXME: Skipping StructValues because this repeated WKT is currently not supported.
	// FIXME: Skipping AnyValue because this WKT is currently not supported.
	// FIXME: Skipping AnyValues because this repeated WKT is currently not supported.
}

// SetFromFlags sets the MessageWithWKTs message from flags.
func (m *MessageWithWKTs) SetFromFlags(flags *pflag.FlagSet, prefix string) (paths []string, err error) {
	if val, changed, err := flagsplugin.GetFloat64(flags, flagsplugin.Prefix("double_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.DoubleValue = &wrapperspb.DoubleValue{Value: val}
		paths = append(paths, flagsplugin.Prefix("double_value", prefix))
	}
	if val, changed, err := flagsplugin.GetFloat64Slice(flags, flagsplugin.Prefix("double_values", prefix)); err != nil {
		return nil, err
	} else if changed {
		for _, value := range val {
			v := &wrapperspb.DoubleValue{Value: value}
			m.DoubleValues = append(m.DoubleValues, v)
		}
		paths = append(paths, flagsplugin.Prefix("double_values", prefix))
	}
	if val, changed, err := flagsplugin.GetFloat32(flags, flagsplugin.Prefix("float_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.FloatValue = &wrapperspb.FloatValue{Value: val}
		paths = append(paths, flagsplugin.Prefix("float_value", prefix))
	}
	if val, changed, err := flagsplugin.GetFloat32Slice(flags, flagsplugin.Prefix("float_values", prefix)); err != nil {
		return nil, err
	} else if changed {
		for _, value := range val {
			v := &wrapperspb.FloatValue{Value: value}
			m.FloatValues = append(m.FloatValues, v)
		}
		paths = append(paths, flagsplugin.Prefix("float_values", prefix))
	}
	if val, changed, err := flagsplugin.GetInt32(flags, flagsplugin.Prefix("int32_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.Int32Value = &wrapperspb.Int32Value{Value: val}
		paths = append(paths, flagsplugin.Prefix("int32_value", prefix))
	}
	if val, changed, err := flagsplugin.GetInt32Slice(flags, flagsplugin.Prefix("int32_values", prefix)); err != nil {
		return nil, err
	} else if changed {
		for _, value := range val {
			v := &wrapperspb.Int32Value{Value: value}
			m.Int32Values = append(m.Int32Values, v)
		}
		paths = append(paths, flagsplugin.Prefix("int32_values", prefix))
	}
	if val, changed, err := flagsplugin.GetInt64(flags, flagsplugin.Prefix("int64_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.Int64Value = &wrapperspb.Int64Value{Value: val}
		paths = append(paths, flagsplugin.Prefix("int64_value", prefix))
	}
	if val, changed, err := flagsplugin.GetInt64Slice(flags, flagsplugin.Prefix("int64_values", prefix)); err != nil {
		return nil, err
	} else if changed {
		for _, value := range val {
			v := &wrapperspb.Int64Value{Value: value}
			m.Int64Values = append(m.Int64Values, v)
		}
		paths = append(paths, flagsplugin.Prefix("int64_values", prefix))
	}
	if val, changed, err := flagsplugin.GetUint32(flags, flagsplugin.Prefix("uint32_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.Uint32Value = &wrapperspb.UInt32Value{Value: val}
		paths = append(paths, flagsplugin.Prefix("uint32_value", prefix))
	}
	if val, changed, err := flagsplugin.GetUint32Slice(flags, flagsplugin.Prefix("uint32_values", prefix)); err != nil {
		return nil, err
	} else if changed {
		for _, value := range val {
			v := &wrapperspb.UInt32Value{Value: value}
			m.Uint32Values = append(m.Uint32Values, v)
		}
		paths = append(paths, flagsplugin.Prefix("uint32_values", prefix))
	}
	if val, changed, err := flagsplugin.GetUint64(flags, flagsplugin.Prefix("uint64_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.Uint64Value = &wrapperspb.UInt64Value{Value: val}
		paths = append(paths, flagsplugin.Prefix("uint64_value", prefix))
	}
	if val, changed, err := flagsplugin.GetUint64Slice(flags, flagsplugin.Prefix("uint64_values", prefix)); err != nil {
		return nil, err
	} else if changed {
		for _, value := range val {
			v := &wrapperspb.UInt64Value{Value: value}
			m.Uint64Values = append(m.Uint64Values, v)
		}
		paths = append(paths, flagsplugin.Prefix("uint64_values", prefix))
	}
	if val, changed, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("bool_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.BoolValue = &wrapperspb.BoolValue{Value: val}
		paths = append(paths, flagsplugin.Prefix("bool_value", prefix))
	}
	if val, changed, err := flagsplugin.GetBoolSlice(flags, flagsplugin.Prefix("bool_values", prefix)); err != nil {
		return nil, err
	} else if changed {
		for _, value := range val {
			v := &wrapperspb.BoolValue{Value: value}
			m.BoolValues = append(m.BoolValues, v)
		}
		paths = append(paths, flagsplugin.Prefix("bool_values", prefix))
	}
	if val, changed, err := flagsplugin.GetString(flags, flagsplugin.Prefix("string_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.StringValue = &wrapperspb.StringValue{Value: val}
		paths = append(paths, flagsplugin.Prefix("string_value", prefix))
	}
	if val, changed, err := flagsplugin.GetStringSlice(flags, flagsplugin.Prefix("string_values", prefix)); err != nil {
		return nil, err
	} else if changed {
		for _, value := range val {
			v := &wrapperspb.StringValue{Value: value}
			m.StringValues = append(m.StringValues, v)
		}
		paths = append(paths, flagsplugin.Prefix("string_values", prefix))
	}
	if val, changed, err := flagsplugin.GetBytes(flags, flagsplugin.Prefix("bytes_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.BytesValue = &wrapperspb.BytesValue{Value: val}
		paths = append(paths, flagsplugin.Prefix("bytes_value", prefix))
	}
	if val, changed, err := flagsplugin.GetBytesSlice(flags, flagsplugin.Prefix("bytes_values", prefix)); err != nil {
		return nil, err
	} else if changed {
		for _, value := range val {
			v := &wrapperspb.BytesValue{Value: value}
			m.BytesValues = append(m.BytesValues, v)
		}
		paths = append(paths, flagsplugin.Prefix("bytes_values", prefix))
	}
	// FIXME: Skipping EmptyValue because this WKT is not supported.
	// FIXME: Skipping EmptyValues because this repeated WKT is not supported
	if val, changed, err := flagsplugin.GetTimestamp(flags, flagsplugin.Prefix("timestamp_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.TimestampValue = golang.SetTimestamp(val)
		paths = append(paths, flagsplugin.Prefix("timestamp_value", prefix))
	}
	if val, changed, err := flagsplugin.GetTimestampSlice(flags, flagsplugin.Prefix("timestamp_values", prefix)); err != nil {
		return nil, err
	} else if changed {
		for _, value := range val {
			v := golang.SetTimestamp(value)
			m.TimestampValues = append(m.TimestampValues, v)
		}
		paths = append(paths, flagsplugin.Prefix("timestamp_values", prefix))
	}
	if val, changed, err := flagsplugin.GetDuration(flags, flagsplugin.Prefix("duration_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.DurationValue = golang.SetDuration(val)
		paths = append(paths, flagsplugin.Prefix("duration_value", prefix))
	}
	if val, changed, err := flagsplugin.GetDurationSlice(flags, flagsplugin.Prefix("duration_values", prefix)); err != nil {
		return nil, err
	} else if changed {
		for _, value := range val {
			v := golang.SetDuration(value)
			m.DurationValues = append(m.DurationValues, v)
		}
		paths = append(paths, flagsplugin.Prefix("duration_values", prefix))
	}
	if val, changed, err := flagsplugin.GetStringSlice(flags, flagsplugin.Prefix("field_mask_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.FieldMaskValue = golang.SetFieldMask(val)
		paths = append(paths, flagsplugin.Prefix("field_mask_value", prefix))
	}
	// FIXME: Skipping FieldMaskValues because this repeated WKT is not supported
	// FIXME: Skipping ValueValue because this WKT is not supported.
	// FIXME: Skipping ValueValues because this repeated WKT is not supported
	// FIXME: Skipping ListValueValue because this WKT is not supported.
	// FIXME: Skipping ListValueValues because this repeated WKT is not supported
	// FIXME: Skipping StructValue because this WKT is not supported.
	// FIXME: Skipping StructValues because this repeated WKT is not supported
	// FIXME: Skipping AnyValue because this WKT is not supported.
	// FIXME: Skipping AnyValues because this repeated WKT is not supported
	return paths, nil
}

// AddSelectFlagsForMessageWithOneofWKTs adds flags to select fields in MessageWithOneofWKTs.
func AddSelectFlagsForMessageWithOneofWKTs(flags *pflag.FlagSet, prefix string, hidden bool) {
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.double-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value.double-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.float-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value.float-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.int32-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value.int32-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.int64-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value.int64-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.uint32-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value.uint32-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.uint64-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value.uint64-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.bool-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value.bool-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.string-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value.string-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.bytes-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value.bytes-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.empty-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value.empty-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.timestamp-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value.timestamp-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.duration-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value.duration-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.field-mask-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value.field-mask-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.value-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value.value-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.list-value-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value.list-value-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.struct-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value.struct-value", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.any-value", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("value.any-value", prefix), false), flagsplugin.WithHidden(hidden)))
}

// SelectFromFlags outputs the fieldmask paths forMessageWithOneofWKTs message from select flags.
func PathsFromSelectFlagsForMessageWithOneofWKTs(flags *pflag.FlagSet, prefix string) (paths []string, err error) {
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.double_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value.double_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.float_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value.float_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.int32_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value.int32_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.int64_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value.int64_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.uint32_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value.uint32_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.uint64_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value.uint64_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.bool_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value.bool_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.string_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value.string_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.bytes_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value.bytes_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.empty_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value.empty_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.timestamp_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value.timestamp_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.duration_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value.duration_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.field_mask_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value.field_mask_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.value_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value.value_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.list_value_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value.list_value_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.struct_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value.struct_value", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.any_value", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("value.any_value", prefix))
	}
	return paths, nil
}

// AddSetFlagsForMessageWithOneofWKTs adds flags to select fields in MessageWithOneofWKTs.
func AddSetFlagsForMessageWithOneofWKTs(flags *pflag.FlagSet, prefix string, hidden bool) {
	flags.AddFlag(flagsplugin.NewFloat64Flag(flagsplugin.Prefix("value.double-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewFloat32Flag(flagsplugin.Prefix("value.float-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewInt32Flag(flagsplugin.Prefix("value.int32-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewInt64Flag(flagsplugin.Prefix("value.int64-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewUint32Flag(flagsplugin.Prefix("value.uint32-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewUint64Flag(flagsplugin.Prefix("value.uint64-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("value.bool-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewStringFlag(flagsplugin.Prefix("value.string-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBytesFlag(flagsplugin.Prefix("value.bytes-value", prefix), "", flagsplugin.WithHidden(hidden)))
	// FIXME: Skipping EmptyValue because this WKT is currently not supported.
	flags.AddFlag(flagsplugin.NewTimestampFlag(flagsplugin.Prefix("value.timestamp-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewDurationFlag(flagsplugin.Prefix("value.duration-value", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewStringSliceFlag(flagsplugin.Prefix("value.field-mask-value", prefix), "", flagsplugin.WithHidden(hidden)))
	// FIXME: Skipping ValueValue because this WKT is currently not supported.
	// FIXME: Skipping ListValueValue because this WKT is currently not supported.
	// FIXME: Skipping StructValue because this WKT is currently not supported.
	// FIXME: Skipping AnyValue because this WKT is currently not supported.
}

// SetFromFlags sets the MessageWithOneofWKTs message from flags.
func (m *MessageWithOneofWKTs) SetFromFlags(flags *pflag.FlagSet, prefix string) (paths []string, err error) {
	if val, changed, err := flagsplugin.GetFloat64(flags, flagsplugin.Prefix("value.double_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		ov := &MessageWithOneofWKTs_DoubleValue{}
		ov.DoubleValue = &wrapperspb.DoubleValue{Value: val}
		paths = append(paths, flagsplugin.Prefix("value.double_value", prefix))
		m.Value = ov
	}
	if val, changed, err := flagsplugin.GetFloat32(flags, flagsplugin.Prefix("value.float_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		ov := &MessageWithOneofWKTs_FloatValue{}
		ov.FloatValue = &wrapperspb.FloatValue{Value: val}
		paths = append(paths, flagsplugin.Prefix("value.float_value", prefix))
		m.Value = ov
	}
	if val, changed, err := flagsplugin.GetInt32(flags, flagsplugin.Prefix("value.int32_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		ov := &MessageWithOneofWKTs_Int32Value{}
		ov.Int32Value = &wrapperspb.Int32Value{Value: val}
		paths = append(paths, flagsplugin.Prefix("value.int32_value", prefix))
		m.Value = ov
	}
	if val, changed, err := flagsplugin.GetInt64(flags, flagsplugin.Prefix("value.int64_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		ov := &MessageWithOneofWKTs_Int64Value{}
		ov.Int64Value = &wrapperspb.Int64Value{Value: val}
		paths = append(paths, flagsplugin.Prefix("value.int64_value", prefix))
		m.Value = ov
	}
	if val, changed, err := flagsplugin.GetUint32(flags, flagsplugin.Prefix("value.uint32_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		ov := &MessageWithOneofWKTs_Uint32Value{}
		ov.Uint32Value = &wrapperspb.UInt32Value{Value: val}
		paths = append(paths, flagsplugin.Prefix("value.uint32_value", prefix))
		m.Value = ov
	}
	if val, changed, err := flagsplugin.GetUint64(flags, flagsplugin.Prefix("value.uint64_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		ov := &MessageWithOneofWKTs_Uint64Value{}
		ov.Uint64Value = &wrapperspb.UInt64Value{Value: val}
		paths = append(paths, flagsplugin.Prefix("value.uint64_value", prefix))
		m.Value = ov
	}
	if val, changed, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("value.bool_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		ov := &MessageWithOneofWKTs_BoolValue{}
		ov.BoolValue = &wrapperspb.BoolValue{Value: val}
		paths = append(paths, flagsplugin.Prefix("value.bool_value", prefix))
		m.Value = ov
	}
	if val, changed, err := flagsplugin.GetString(flags, flagsplugin.Prefix("value.string_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		ov := &MessageWithOneofWKTs_StringValue{}
		ov.StringValue = &wrapperspb.StringValue{Value: val}
		paths = append(paths, flagsplugin.Prefix("value.string_value", prefix))
		m.Value = ov
	}
	if val, changed, err := flagsplugin.GetBytes(flags, flagsplugin.Prefix("value.bytes_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		ov := &MessageWithOneofWKTs_BytesValue{}
		ov.BytesValue = &wrapperspb.BytesValue{Value: val}
		paths = append(paths, flagsplugin.Prefix("value.bytes_value", prefix))
		m.Value = ov
	}
	// FIXME: Skipping EmptyValue because this WKT is not supported.
	if val, changed, err := flagsplugin.GetTimestamp(flags, flagsplugin.Prefix("value.timestamp_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		ov := &MessageWithOneofWKTs_TimestampValue{}
		ov.TimestampValue = golang.SetTimestamp(val)
		paths = append(paths, flagsplugin.Prefix("value.timestamp_value", prefix))
		m.Value = ov
	}
	if val, changed, err := flagsplugin.GetDuration(flags, flagsplugin.Prefix("value.duration_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		ov := &MessageWithOneofWKTs_DurationValue{}
		ov.DurationValue = golang.SetDuration(val)
		paths = append(paths, flagsplugin.Prefix("value.duration_value", prefix))
		m.Value = ov
	}
	if val, changed, err := flagsplugin.GetStringSlice(flags, flagsplugin.Prefix("value.field_mask_value", prefix)); err != nil {
		return nil, err
	} else if changed {
		ov := &MessageWithOneofWKTs_FieldMaskValue{}
		ov.FieldMaskValue = golang.SetFieldMask(val)
		paths = append(paths, flagsplugin.Prefix("value.field_mask_value", prefix))
		m.Value = ov
	}
	// FIXME: Skipping ValueValue because this WKT is not supported.
	// FIXME: Skipping ListValueValue because this WKT is not supported.
	// FIXME: Skipping StructValue because this WKT is not supported.
	// FIXME: Skipping AnyValue because this WKT is not supported.
	return paths, nil
}

// AddSelectFlagsForMessageWithWKTMaps adds flags to select fields in MessageWithWKTMaps.
func AddSelectFlagsForMessageWithWKTMaps(flags *pflag.FlagSet, prefix string, hidden bool) {
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-double-map", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-double-map", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-float-map", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-float-map", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-int32-map", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-int32-map", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-int64-map", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-int64-map", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-uint32-map", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-uint32-map", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-uint64-map", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-uint64-map", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-bool-map", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-bool-map", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-string-map", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-string-map", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-bytes-map", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-bytes-map", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-empty-map", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-empty-map", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-timestamp-map", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-timestamp-map", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-duration-map", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-duration-map", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-field-mask-map", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-field-mask-map", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-value-map", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-value-map", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-list-value-map", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-list-value-map", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-struct-map", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-struct-map", prefix), false), flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewBoolFlag(flagsplugin.Prefix("string-any-map", prefix), flagsplugin.SelectDesc(flagsplugin.Prefix("string-any-map", prefix), false), flagsplugin.WithHidden(hidden)))
}

// SelectFromFlags outputs the fieldmask paths forMessageWithWKTMaps message from select flags.
func PathsFromSelectFlagsForMessageWithWKTMaps(flags *pflag.FlagSet, prefix string) (paths []string, err error) {
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_double_map", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_double_map", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_float_map", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_float_map", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_int32_map", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_int32_map", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_int64_map", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_int64_map", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_uint32_map", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_uint32_map", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_uint64_map", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_uint64_map", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_bool_map", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_bool_map", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_string_map", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_string_map", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_bytes_map", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_bytes_map", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_empty_map", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_empty_map", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_timestamp_map", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_timestamp_map", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_duration_map", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_duration_map", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_field_mask_map", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_field_mask_map", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_value_map", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_value_map", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_list_value_map", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_list_value_map", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_struct_map", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_struct_map", prefix))
	}
	if val, selected, err := flagsplugin.GetBool(flags, flagsplugin.Prefix("string_any_map", prefix)); err != nil {
		return nil, err
	} else if selected && val {
		paths = append(paths, flagsplugin.Prefix("string_any_map", prefix))
	}
	return paths, nil
}

// AddSetFlagsForMessageWithWKTMaps adds flags to select fields in MessageWithWKTMaps.
func AddSetFlagsForMessageWithWKTMaps(flags *pflag.FlagSet, prefix string, hidden bool) {
	flags.AddFlag(flagsplugin.NewStringFloat64MapFlag(flagsplugin.Prefix("string-double-map", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewStringFloat32MapFlag(flagsplugin.Prefix("string-float-map", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewStringInt32MapFlag(flagsplugin.Prefix("string-int32-map", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewStringInt64MapFlag(flagsplugin.Prefix("string-int64-map", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewStringUint32MapFlag(flagsplugin.Prefix("string-uint32-map", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewStringUint64MapFlag(flagsplugin.Prefix("string-uint64-map", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewStringBoolMapFlag(flagsplugin.Prefix("string-bool-map", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewStringStringMapFlag(flagsplugin.Prefix("string-string-map", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewStringBytesMapFlag(flagsplugin.Prefix("string-bytes-map", prefix), "", flagsplugin.WithHidden(hidden)))
	// FIXME: Skipping StringEmptyMap because maps with message value types are currently not supported.
	flags.AddFlag(flagsplugin.NewStringTimestampMapFlag(flagsplugin.Prefix("string-timestamp-map", prefix), "", flagsplugin.WithHidden(hidden)))
	flags.AddFlag(flagsplugin.NewStringDurationMapFlag(flagsplugin.Prefix("string-duration-map", prefix), "", flagsplugin.WithHidden(hidden)))
	// FIXME: Skipping StringFieldMaskMap because maps with message value types are currently not supported.
	// FIXME: Skipping StringValueMap because maps with message value types are currently not supported.
	// FIXME: Skipping StringListValueMap because maps with message value types are currently not supported.
	// FIXME: Skipping StringStructMap because maps with message value types are currently not supported.
	// FIXME: Skipping StringAnyMap because maps with message value types are currently not supported.
}

// SetFromFlags sets the MessageWithWKTMaps message from flags.
func (m *MessageWithWKTMaps) SetFromFlags(flags *pflag.FlagSet, prefix string) (paths []string, err error) {
	if val, changed, err := flagsplugin.GetStringFloat64Map(flags, flagsplugin.Prefix("string_double_map", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.StringDoubleMap = make(map[string]*wrapperspb.DoubleValue)
		for key, value := range val {
			m.StringDoubleMap[key] = &wrapperspb.DoubleValue{Value: value}
		}
		paths = append(paths, flagsplugin.Prefix("string_double_map", prefix))
	}
	if val, changed, err := flagsplugin.GetStringFloat32Map(flags, flagsplugin.Prefix("string_float_map", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.StringFloatMap = make(map[string]*wrapperspb.FloatValue)
		for key, value := range val {
			m.StringFloatMap[key] = &wrapperspb.FloatValue{Value: value}
		}
		paths = append(paths, flagsplugin.Prefix("string_float_map", prefix))
	}
	if val, changed, err := flagsplugin.GetStringInt32Map(flags, flagsplugin.Prefix("string_int32_map", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.StringInt32Map = make(map[string]*wrapperspb.Int32Value)
		for key, value := range val {
			m.StringInt32Map[key] = &wrapperspb.Int32Value{Value: value}
		}
		paths = append(paths, flagsplugin.Prefix("string_int32_map", prefix))
	}
	if val, changed, err := flagsplugin.GetStringInt64Map(flags, flagsplugin.Prefix("string_int64_map", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.StringInt64Map = make(map[string]*wrapperspb.Int64Value)
		for key, value := range val {
			m.StringInt64Map[key] = &wrapperspb.Int64Value{Value: value}
		}
		paths = append(paths, flagsplugin.Prefix("string_int64_map", prefix))
	}
	if val, changed, err := flagsplugin.GetStringUint32Map(flags, flagsplugin.Prefix("string_uint32_map", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.StringUint32Map = make(map[string]*wrapperspb.UInt32Value)
		for key, value := range val {
			m.StringUint32Map[key] = &wrapperspb.UInt32Value{Value: value}
		}
		paths = append(paths, flagsplugin.Prefix("string_uint32_map", prefix))
	}
	if val, changed, err := flagsplugin.GetStringUint64Map(flags, flagsplugin.Prefix("string_uint64_map", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.StringUint64Map = make(map[string]*wrapperspb.UInt64Value)
		for key, value := range val {
			m.StringUint64Map[key] = &wrapperspb.UInt64Value{Value: value}
		}
		paths = append(paths, flagsplugin.Prefix("string_uint64_map", prefix))
	}
	if val, changed, err := flagsplugin.GetStringBoolMap(flags, flagsplugin.Prefix("string_bool_map", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.StringBoolMap = make(map[string]*wrapperspb.BoolValue)
		for key, value := range val {
			m.StringBoolMap[key] = &wrapperspb.BoolValue{Value: value}
		}
		paths = append(paths, flagsplugin.Prefix("string_bool_map", prefix))
	}
	if val, changed, err := flagsplugin.GetStringStringMap(flags, flagsplugin.Prefix("string_string_map", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.StringStringMap = make(map[string]*wrapperspb.StringValue)
		for key, value := range val {
			m.StringStringMap[key] = &wrapperspb.StringValue{Value: value}
		}
		paths = append(paths, flagsplugin.Prefix("string_string_map", prefix))
	}
	if val, changed, err := flagsplugin.GetStringBytesMap(flags, flagsplugin.Prefix("string_bytes_map", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.StringBytesMap = make(map[string]*wrapperspb.BytesValue)
		for key, value := range val {
			m.StringBytesMap[key] = &wrapperspb.BytesValue{Value: value}
		}
		paths = append(paths, flagsplugin.Prefix("string_bytes_map", prefix))
	}
	// FIXME: Skipping StringEmptyMap because maps with message value types are currently not supported.
	if val, changed, err := flagsplugin.GetStringTimestampMap(flags, flagsplugin.Prefix("string_timestamp_map", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.StringTimestampMap = make(map[string]*timestamppb.Timestamp)
		for key, value := range val {
			m.StringTimestampMap[key] = golang.SetTimestamp(value)
		}
		paths = append(paths, flagsplugin.Prefix("string_timestamp_map", prefix))
	}
	if val, changed, err := flagsplugin.GetStringDurationMap(flags, flagsplugin.Prefix("string_duration_map", prefix)); err != nil {
		return nil, err
	} else if changed {
		m.StringDurationMap = make(map[string]*durationpb.Duration)
		for key, value := range val {
			m.StringDurationMap[key] = golang.SetDuration(value)
		}
		paths = append(paths, flagsplugin.Prefix("string_duration_map", prefix))
	}
	// FIXME: Skipping StringFieldMaskMap because maps with message value types are currently not supported.
	// FIXME: Skipping StringValueMap because maps with message value types are currently not supported.
	// FIXME: Skipping StringListValueMap because maps with message value types are currently not supported.
	// FIXME: Skipping StringStructMap because maps with message value types are currently not supported.
	// FIXME: Skipping StringAnyMap because maps with message value types are currently not supported.
	return paths, nil
}
